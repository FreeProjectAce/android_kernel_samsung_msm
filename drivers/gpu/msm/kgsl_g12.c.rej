--- drivers/gpu/msm/kgsl_g12.c	2011-04-03 14:16:18.000000000 +0700
+++ drivers/gpu/msm/kgsl_g12.c	2011-12-23 19:21:50.000000000 +0700
@@ -67,9 +69,16 @@
 #define KGSL_G12_TIMESTAMP_EPSILON 20000
 #define KGSL_G12_IDLE_COUNT_MAX 1000000
 
+#define KGSL_G12_CMDWINDOW_TARGET_MASK		0x000000FF
+#define KGSL_G12_CMDWINDOW_ADDR_MASK		0x00FFFF00
+#define KGSL_G12_CMDWINDOW_TARGET_SHIFT		0
+#define KGSL_G12_CMDWINDOW_ADDR_SHIFT		8
+
 static int kgsl_g12_start(struct kgsl_device *device, unsigned int init_ram);
 static int kgsl_g12_stop(struct kgsl_device *device);
-static int kgsl_g12_idle(struct kgsl_device *device, unsigned int timeout);
+static int kgsl_g12_wait(struct kgsl_device *device,
+				unsigned int timestamp,
+				unsigned int msecs);
 static int kgsl_g12_waittimestamp(struct kgsl_device *device,
 				unsigned int timestamp,
 				unsigned int msecs);
@@ -189,23 +244,22 @@
 	struct kgsl_device *device = (struct kgsl_device *) data;
 	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
 
-	kgsl_g12_regread(device, ADDR_VGC_IRQSTATUS >> 2, &status);
+	kgsl_g12_regread_isr(device, ADDR_VGC_IRQSTATUS >> 2, &status);
 
 	if (status & GSL_VGC_INT_MASK) {
-		kgsl_g12_regwrite(device,
+		kgsl_g12_regwrite_isr(device,
 			ADDR_VGC_IRQSTATUS >> 2, status & GSL_VGC_INT_MASK);
 
 		result = IRQ_HANDLED;
 
 		if (status & REG_VGC_IRQSTATUS__FIFO_MASK)
-			KGSL_DRV_ERR("g12 fifo interrupt\n");
+			KGSL_DRV_ERR(device, "g12 fifo interrupt\n");
 		if (status & REG_VGC_IRQSTATUS__MH_MASK)
 			kgsl_mh_intrcallback(device);
 		if (status & REG_VGC_IRQSTATUS__G2D_MASK) {
 			int count;
 
-			KGSL_DRV_VDBG("g12 g2d interrupt\n");
-			kgsl_g12_regread(device,
+			kgsl_g12_regread_isr(device,
 					 ADDR_VGC_IRQ_ACTIVE_CNT >> 2,
 					 &count);
 
@@ -307,273 +357,67 @@
 	return 0;
 }
 
-int __init
-kgsl_g12_init_pwrctrl(struct kgsl_device *device)
-{
-	int result = 0;
-	const char *pclk_name;
-	struct clk *clk, *pclk;
-	struct platform_device *pdev = kgsl_driver.pdev;
-	struct kgsl_platform_data *pdata = pdev->dev.platform_data;
-	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
-	struct msm_bus_scale_pdata *bus_table = NULL;
-
-	if (device->id == KGSL_DEVICE_2D0) {
-		clk = clk_get(&pdev->dev, pdata->grp2d0_clk_name);
-		pclk = clk_get(&pdev->dev, pdata->grp2d0_pclk_name);
-		pclk_name = pdata->grp2d0_pclk_name;
-		bus_table = pdata->grp2d0_bus_scale_table;
-	} else {
-		clk = clk_get(&pdev->dev, pdata->grp2d1_clk_name);
-		pclk = clk_get(&pdev->dev, pdata->grp2d1_pclk_name);
-		pclk_name = pdata->grp2d1_pclk_name;
-		bus_table = pdata->grp2d1_bus_scale_table;
-	}
-
-	/* error check resources */
-	if (IS_ERR(clk)) {
-		clk = NULL;
-		result = PTR_ERR(clk);
-		KGSL_DRV_ERR("clk_get(%s) returned %d\n",
-						pdata->grp2d0_clk_name, result);
-		goto done;
-	}
-
-	if (pclk_name && IS_ERR(pclk)) {
-		pclk = NULL;
-		result = PTR_ERR(pclk);
-		KGSL_DRV_ERR("clk_get(%s) returned %d\n",
-					 pclk_name, result);
-		goto done;
-	}
-
-	device->pwrctrl.gpu_reg = regulator_get(NULL, g12_device->regulator);
-
-	if (IS_ERR(device->pwrctrl.gpu_reg))
-		device->pwrctrl.gpu_reg = NULL;
-
-	device->pwrctrl.interrupt_num =
-		platform_get_irq_byname(pdev, g12_device->irqname);
-
-	if (device->pwrctrl.interrupt_num <= 0) {
-		KGSL_DRV_ERR("platform_get_irq_byname() returned %d\n",
-					 device->pwrctrl.interrupt_num);
-		result = -EINVAL;
-		goto done;
-	}
-
-	/* save resources to pwrctrl struct */
-	if (pdata->set_grp2d_async != NULL)
-		pdata->set_grp2d_async();
-
-	if (pdata->max_grp2d_freq) {
-		device->pwrctrl.clk_freq[KGSL_MIN_FREQ] =
-			clk_round_rate(clk, pdata->min_grp2d_freq);
-		device->pwrctrl.clk_freq[KGSL_MAX_FREQ] =
-			clk_round_rate(clk, pdata->max_grp2d_freq);
-		clk_set_rate(clk, device->pwrctrl.clk_freq[KGSL_MIN_FREQ]);
-	}
-
-	device->pwrctrl.power_flags = KGSL_PWRFLAGS_CLK_OFF |
-		KGSL_PWRFLAGS_AXI_OFF | KGSL_PWRFLAGS_POWER_OFF |
-		KGSL_PWRFLAGS_IRQ_OFF;
-	device->pwrctrl.nap_allowed = pdata->nap_allowed;
-	device->pwrctrl.clk_freq[KGSL_AXI_HIGH] = pdata->high_axi_2d;
-	device->pwrctrl.grp_clk = clk;
-	device->pwrctrl.grp_src_clk = clk;
-	device->pwrctrl.grp_pclk = pclk;
-	device->pwrctrl.pwr_rail = PWR_RAIL_GRP_2D_CLK;
-	device->pwrctrl.interval_timeout = pdata->idle_timeout_2d;
-
-	if (internal_pwr_rail_mode(device->pwrctrl.pwr_rail,
-						PWR_RAIL_CTL_MANUAL)) {
-		KGSL_DRV_ERR("call internal_pwr_rail_mode failed\n");
-		result = -EINVAL;
-		goto done;
-	}
-
-	clk = clk_get(NULL, "ebi1_kgsl_clk");
-	if (IS_ERR(clk))
-		clk = NULL;
-	else
-		clk_set_rate(clk, device->pwrctrl.clk_freq[KGSL_AXI_HIGH]*1000);
-	device->pwrctrl.ebi1_clk = clk;
+static void kgsl_g12_getfunctable(struct kgsl_functable *ftbl);
 
-	if (bus_table) {
-		device->pwrctrl.pcl = msm_bus_scale_register_client(bus_table);
-		if (!device->pwrctrl.pcl) {
-			KGSL_DRV_ERR("msm_bus_scale_register_client failed "
-				     "id %d table %p", device->id,
-				     bus_table);
-			result = -EINVAL;
-			goto done;
-		}
-	}
-done:
-	return result;
-}
-
-int __init
-kgsl_g12_init(struct kgsl_device *device)
+static int __devinit kgsl_2d_probe(struct platform_device *pdev)
 {
 	int status = -EINVAL;
-	struct kgsl_memregion *regspace = &device->regspace;
-	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
-	struct resource *res;
-	struct kgsl_platform_data *pdata = NULL;
-
-	KGSL_DRV_VDBG("enter (device=%p)\n", device);
-
-	/* initilization of timestamp wait */
-	init_waitqueue_head(&(g12_device->wait_timestamp_wq));
-
-	res = platform_get_resource_byname(kgsl_driver.pdev, IORESOURCE_MEM,
-					   g12_device->iomemname);
-
-	if (res == NULL) {
-		KGSL_DRV_ERR("platform_get_resource_byname failed\n");
-		status = -EINVAL;
-		goto error;
-	}
-
-	regspace->mmio_phys_base = res->start;
-	regspace->sizebytes = resource_size(res);
-
-	if (regspace->mmio_phys_base == 0 || regspace->sizebytes == 0) {
-		KGSL_DRV_ERR("dev %d invalid regspace\n", device->id);
-		status = -ENODEV;
-		goto error;
-	}
-	if (!request_mem_region(regspace->mmio_phys_base,
-				regspace->sizebytes, DRIVER_NAME)) {
-		KGSL_DRV_ERR("request_mem_region failed for " \
-					"register memory\n");
-		status = -ENODEV;
-		goto error;
-	}
-
-	regspace->mmio_virt_base = ioremap(regspace->mmio_phys_base,
-					   regspace->sizebytes);
-	KGSL_MEM_INFO("ioremap(regs) = %p\n", regspace->mmio_virt_base);
-	if (regspace->mmio_virt_base == NULL) {
-		KGSL_DRV_ERR("ioremap failed for register memory\n");
-		status = -ENODEV;
-		goto error_release_mem;
-	}
-
-	status = request_irq(device->pwrctrl.interrupt_num, kgsl_g12_isr,
-			     IRQF_TRIGGER_HIGH, DRIVER_NAME, device);
-	if (status) {
-		KGSL_DRV_ERR("request_irq(%d) returned %d\n",
-			      device->pwrctrl.interrupt_num, status);
-		goto error_iounmap;
-	}
-	device->pwrctrl.have_irq = 1;
-	disable_irq(device->pwrctrl.interrupt_num);
-
-	KGSL_DRV_INFO("dev_id %d regs phys 0x%08x size 0x%08x virt %p\n",
-			device->id, regspace->mmio_phys_base,
-			regspace->sizebytes, regspace->mmio_virt_base);
+	struct kgsl_device *device = NULL;
+	struct kgsl_g12_device *g12_device;
 
-	kgsl_cffdump_open(device->id);
+	device = (struct kgsl_device *)pdev->id_entry->driver_data;
+	device->pdev = pdev;
 
-	init_completion(&device->hwaccess_gate);
-	init_completion(&device->suspend_gate);
 	kgsl_g12_getfunctable(&device->ftbl);
-	ATOMIC_INIT_NOTIFIER_HEAD(&device->ts_notifier_list);
-
-	setup_timer(&device->idle_timer, kgsl_timer, (unsigned long) device);
-	status = kgsl_create_device_workqueue(device);
-	if (status)
-		goto error_free_irq;
 
-	INIT_WORK(&device->idle_check_ws, kgsl_idle_check);
+	g12_device = KGSL_G12_DEVICE(device);
+	spin_lock_init(&g12_device->cmdwin_lock);
 
-	INIT_LIST_HEAD(&device->memqueue);
 	status = kgsl_g12_cmdstream_init(device);
 	if (status != 0)
-		goto error_dest_work_q;
-
-	pdata = kgsl_driver.pdev->dev.platform_data;
-	device->mmu.va_range = pdata->pt_va_size;
+		goto error;
 
-	status = kgsl_mmu_init(device);
-	if (status != 0)
+	status = kgsl_device_probe(device, kgsl_g12_isr);
+	if (status)
 		goto error_close_cmdstream;
 
-	status = kgsl_sharedmem_alloc_coherent(&device->memstore,
-						sizeof(device->memstore));
-	if (status != 0)
-		goto error_close_mmu;
-
-	kgsl_sharedmem_set(&device->memstore, 0, 0, device->memstore.size);
-
-	wake_lock_init(&device->idle_wakelock, WAKE_LOCK_IDLE, device->name);
-	return 0;
+	return status;
 
-error_close_mmu:
-	kgsl_mmu_close(device);
 error_close_cmdstream:
 	kgsl_g12_cmdstream_close(device);
-error_dest_work_q:
-	destroy_workqueue(device->work_queue);
-	device->work_queue = NULL;
-error_free_irq:
-	free_irq(device->pwrctrl.interrupt_num, NULL);
-	device->pwrctrl.have_irq = 0;
-error_iounmap:
-	iounmap(regspace->mmio_virt_base);
-	regspace->mmio_virt_base = NULL;
-error_release_mem:
-	release_mem_region(regspace->mmio_phys_base, regspace->sizebytes);
 error:
+	device->pdev = NULL;
 	return status;
 }
 
-int kgsl_g12_close(struct kgsl_device *device)
+static int __devexit kgsl_2d_remove(struct platform_device *pdev)
 {
-	struct kgsl_memregion *regspace = &device->regspace;
+	struct kgsl_device *device = NULL;
 
-	if (device->memstore.hostptr)
-		kgsl_sharedmem_free(&device->memstore);
+	device = (struct kgsl_device *)pdev->id_entry->driver_data;
 
-	kgsl_mmu_close(device);
+	kgsl_device_remove(device);
 
 	kgsl_g12_cmdstream_close(device);
 
-	if (regspace->mmio_virt_base != NULL) {
-		KGSL_MEM_INFO("iounmap(regs) = %p\n",
-				regspace->mmio_virt_base);
-		iounmap(regspace->mmio_virt_base);
-		regspace->mmio_virt_base = NULL;
-		release_mem_region(regspace->mmio_phys_base,
-					regspace->sizebytes);
-	}
-
-	kgsl_pwrctrl_close(device);
-	kgsl_cffdump_close(device->id);
-
-	if (device->work_queue) {
-		destroy_workqueue(device->work_queue);
-		device->work_queue = NULL;
-	}
-
-	wake_lock_destroy(&device->idle_wakelock);
-	KGSL_DRV_VDBG("return %d\n", 0);
 	return 0;
 }
 
 static int kgsl_g12_start(struct kgsl_device *device, unsigned int init_ram)
 {
 	int status = 0;
-	KGSL_DRV_VDBG("enter (device=%p)\n", device);
 
 	device->state = KGSL_STATE_INIT;
 	device->requested_state = KGSL_STATE_NONE;
+	KGSL_PWR_WARN(device, "state -> INIT, device %d\n", device->id);
 
-	kgsl_pwrctrl_pwrrail(device, KGSL_PWRFLAGS_POWER_ON);
+	/* Order pwrrail/clk sequence based upon platform. */
+	if (device->pwrctrl.pwrrail_first)
+		kgsl_pwrctrl_pwrrail(device, KGSL_PWRFLAGS_POWER_ON);
 	kgsl_pwrctrl_clk(device, KGSL_PWRFLAGS_CLK_ON);
 	kgsl_pwrctrl_axi(device, KGSL_PWRFLAGS_AXI_ON);
+	if (!device->pwrctrl.pwrrail_first)
+		kgsl_pwrctrl_pwrrail(device, KGSL_PWRFLAGS_POWER_ON);
 
 	/* Set up MH arbiter.  MH offsets are considered to be dword
 	 * based, therefore no down shift. */
@@ -674,41 +508,36 @@
 		break;
 
 	default:
-	KGSL_DRV_ERR("invalid property: %d\n", type);
-	status = -EINVAL;
-
+		KGSL_DRV_ERR(device, "invalid property: %d\n", type);
+		status = -EINVAL;
 	}
 	return status;
 }
 
-static int kgsl_g12_idle(struct kgsl_device *device, unsigned int timeout)
+int kgsl_g12_idle(struct kgsl_device *device, unsigned int timeout)
 {
-	int status = KGSL_SUCCESS;
+	int status = 0;
 	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
 
-	KGSL_DRV_VDBG("enter (device=%p, timeout=%d)\n", device, timeout);
-
 	if (g12_device->current_timestamp > g12_device->timestamp)
-		status = kgsl_g12_waittimestamp(device,
+		status = kgsl_g12_wait(device,
 					g12_device->current_timestamp, timeout);
 
 	if (status)
-		KGSL_DRV_ERR("Error, kgsl_g12_waittimestamp() timed out\n");
-
-	KGSL_DRV_VDBG("return %d\n", status);
+		KGSL_DRV_ERR(device, "kgsl_g12_waittimestamp() timed out\n");
 
 	return status;
 }
 
 static unsigned int kgsl_g12_isidle(struct kgsl_device *device)
 {
-	int status = 0;
+	int status = false;
 	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
 
 	int timestamp = g12_device->timestamp;
 
 	if (timestamp == g12_device->current_timestamp)
-		status = KGSL_TRUE;
+		status = true;
 
 	return status;
 }
@@ -726,71 +555,169 @@
 
 	g12_device->ringbuffer.prevctx = KGSL_G12_INVALID_CONTEXT;
 
-	return KGSL_SUCCESS;
+	return 0;
 }
 
-int kgsl_g12_regread(struct kgsl_device *device, unsigned int offsetwords,
+/* Not all Z180 registers are directly accessible.
+ * The _g12_(read|write)_simple functions below handle the ones that are.
+ */
+static void _g12_regread_simple(struct kgsl_device *device,
+				unsigned int offsetwords,
 				unsigned int *value)
 {
 	unsigned int *reg;
-	kgsl_pre_hwaccess(device);
+
+	BUG_ON(offsetwords * sizeof(uint32_t) >= device->regspace.sizebytes);
+
+	reg = (unsigned int *)(device->regspace.mmio_virt_base
+			+ (offsetwords << 2));
+
+	*value = readl(reg);
+}
+
+static void _g12_regwrite_simple(struct kgsl_device *device,
+				 unsigned int offsetwords,
+				 unsigned int value)
+{
+	unsigned int *reg;
+
+	BUG_ON(offsetwords*sizeof(uint32_t) >= device->regspace.sizebytes);
+
+	reg = (unsigned int *)(device->regspace.mmio_virt_base
+			+ (offsetwords << 2));
+	kgsl_cffdump_regwrite(device->id, offsetwords << 2, value);
+	writel(value, reg);
+}
+
+
+/* The MH registers must be accessed through via a 2 step write, (read|write)
+ * process. These registers may be accessed from interrupt context during
+ * the handling of MH or MMU error interrupts. Therefore a spin lock is used
+ * to ensure that the 2 step sequence is not interrupted.
+ */
+static void _g12_regread_mmu(struct kgsl_device *device,
+			     unsigned int offsetwords,
+			     unsigned int *value)
+{
+	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
+	unsigned long flags;
+
+	spin_lock_irqsave(&g12_device->cmdwin_lock, flags);
+	_g12_regwrite_simple(device, (ADDR_VGC_MH_READ_ADDR >> 2), offsetwords);
+	_g12_regread_simple(device, (ADDR_VGC_MH_DATA_ADDR >> 2), value);
+	spin_unlock_irqrestore(&g12_device->cmdwin_lock, flags);
+}
+
+
+static void _g12_regwrite_mmu(struct kgsl_device *device,
+			      unsigned int offsetwords,
+			      unsigned int value)
+{
+	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
+	unsigned int cmdwinaddr;
+	unsigned long flags;
+
+	cmdwinaddr = ((KGSL_CMDWINDOW_MMU << KGSL_G12_CMDWINDOW_TARGET_SHIFT) &
+			KGSL_G12_CMDWINDOW_TARGET_MASK);
+	cmdwinaddr |= ((offsetwords << KGSL_G12_CMDWINDOW_ADDR_SHIFT) &
+			KGSL_G12_CMDWINDOW_ADDR_MASK);
+
+	spin_lock_irqsave(&g12_device->cmdwin_lock, flags);
+	_g12_regwrite_simple(device, ADDR_VGC_MMUCOMMANDSTREAM >> 2,
+			     cmdwinaddr);
+	_g12_regwrite_simple(device, ADDR_VGC_MMUCOMMANDSTREAM >> 2, value);
+	spin_unlock_irqrestore(&g12_device->cmdwin_lock, flags);
+}
+
+/* the rest of the code doesn't want to think about if it is writing mmu
+ * registers or normal registers so handle it here
+ */
+static void _g12_regread(struct kgsl_device *device, unsigned int offsetwords,
+				unsigned int *value)
+{
 	if ((offsetwords >= ADDR_MH_ARBITER_CONFIG &&
 	     offsetwords <= ADDR_MH_AXI_HALT_CONTROL) ||
 	    (offsetwords >= ADDR_MH_MMU_CONFIG &&
 	     offsetwords <= ADDR_MH_MMU_MPU_END)) {
-		kgsl_g12_regwrite(device, (ADDR_VGC_MH_READ_ADDR >> 2),
-				  offsetwords);
-		reg = (unsigned int *)(device->regspace.mmio_virt_base
-				+ ADDR_VGC_MH_DATA_ADDR);
+		_g12_regread_mmu(device, offsetwords, value);
 	} else {
-		if (offsetwords * sizeof(uint32_t) >=
-				device->regspace.sizebytes) {
-			KGSL_DRV_ERR("invalid offset %d\n", offsetwords);
-			return -ERANGE;
-		}
-
-		reg = (unsigned int *)(device->regspace.mmio_virt_base
-				+ (offsetwords << 2));
+		_g12_regread_simple(device, offsetwords, value);
 	}
-
-	*value = readl(reg);
-
-	return 0;
 }
 
-int kgsl_g12_regwrite(struct kgsl_device *device, unsigned int offsetwords,
+static void _g12_regwrite(struct kgsl_device *device, unsigned int offsetwords,
 				unsigned int value)
 {
-	unsigned int *reg;
-
-	kgsl_pre_hwaccess(device);
 	if ((offsetwords >= ADDR_MH_ARBITER_CONFIG &&
 	     offsetwords <= ADDR_MH_CLNT_INTF_CTRL_CONFIG2) ||
 	    (offsetwords >= ADDR_MH_MMU_CONFIG &&
 	     offsetwords <= ADDR_MH_MMU_MPU_END)) {
-		kgsl_g12_cmdwindow_write(device, KGSL_CMDWINDOW_MMU,
-					 offsetwords, value);
+		_g12_regwrite_mmu(device, offsetwords, value);
+
 	} else {
-		if (offsetwords*sizeof(uint32_t) >=
-				device->regspace.sizebytes) {
-			KGSL_DRV_ERR("invalid offset %d\n", offsetwords);
-			return -ERANGE;
-		}
+		_g12_regwrite_simple(device, offsetwords, value);
+	}
+}
+
+
+void kgsl_g12_regread(struct kgsl_device *device, unsigned int offsetwords,
+				unsigned int *value)
+{
+	kgsl_pre_hwaccess(device);
+	_g12_regread(device, offsetwords, value);
+}
 
-		reg = (unsigned int *)(device->regspace.mmio_virt_base
-				+ (offsetwords << 2));
-		kgsl_cffdump_regwrite(device->id, offsetwords << 2, value);
-		writel(value, reg);
-		/* Drain write buffer */
-		dsb();
-
-		/* Memory fence to ensure all data has posted.  On some systems,
-		 * like 7x27, the register block is not allocated as strongly
-		 * ordered memory.  Adding a memory fence ensures ordering
-		 * during ringbuffer submits.*/
-		mb();
+void kgsl_g12_regread_isr(struct kgsl_device *device, unsigned int offsetwords,
+				unsigned int *value)
+{
+	_g12_regread(device, offsetwords, value);
+}
+
+void kgsl_g12_regwrite(struct kgsl_device *device, unsigned int offsetwords,
+				unsigned int value)
+{
+	kgsl_pre_hwaccess(device);
+	_g12_regwrite(device, offsetwords, value);
+}
+
+void kgsl_g12_regwrite_isr(struct kgsl_device *device, unsigned int offsetwords,
+				unsigned int value)
+{
+	_g12_regwrite(device, offsetwords, value);
+}
+
+int kgsl_g12_cmdwindow_write(struct kgsl_device *device,
+		enum kgsl_cmdwindow_type target, unsigned int addr,
+		unsigned int data)
+{
+	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
+	unsigned int cmdwinaddr;
+	unsigned int cmdstream;
+	unsigned long flags;
+
+	if (target < KGSL_CMDWINDOW_MIN ||
+		target > KGSL_CMDWINDOW_MAX) {
+		KGSL_DRV_ERR(device, "invalid target %d\n", target);
+		return -EINVAL;
 	}
 
+	if (target == KGSL_CMDWINDOW_MMU)
+		cmdstream = ADDR_VGC_MMUCOMMANDSTREAM;
+	else
+		cmdstream = ADDR_VGC_COMMANDSTREAM;
+
+	cmdwinaddr = ((target << KGSL_G12_CMDWINDOW_TARGET_SHIFT) &
+			KGSL_G12_CMDWINDOW_TARGET_MASK);
+	cmdwinaddr |= ((addr << KGSL_G12_CMDWINDOW_ADDR_SHIFT) &
+			KGSL_G12_CMDWINDOW_ADDR_MASK);
+
+	kgsl_pre_hwaccess(device);
+
+	spin_lock_irqsave(&g12_device->cmdwin_lock, flags);
+	_g12_regwrite_simple(device, cmdstream >> 2, cmdwinaddr);
+	_g12_regwrite_simple(device, cmdstream >> 2, data);
+	spin_unlock_irqrestore(&g12_device->cmdwin_lock, flags);
+
 	return 0;
 }
 
@@ -799,75 +726,61 @@
 				unsigned int msecs)
 {
 	int status = -EINVAL;
-	struct kgsl_g12_device *g12_device = KGSL_G12_DEVICE(device);
-	long timeout = 0;
+	mutex_unlock(&device->mutex);
+	status = kgsl_g12_wait(device, timestamp, msecs);
+	mutex_lock(&device->mutex);
 
-	KGSL_DRV_INFO("enter (device=%p,timestamp=%d,timeout=0x%08x)\n",
-			device, timestamp, msecs);
+	return status;
+}
 
-	KGSL_DRV_INFO("current (device=%p,timestamp=%d)\n",
-			device, g12_device->timestamp);
+static int kgsl_g12_wait(struct kgsl_device *device,
+				unsigned int timestamp,
+				unsigned int msecs)
+{
+	int status = -EINVAL;
+	long timeout = 0;
 
-	mutex_unlock(&device->mutex);
 	timeout = wait_io_event_interruptible_timeout(
-			g12_device->wait_timestamp_wq,
+			device->wait_queue,
 			kgsl_check_timestamp(device, timestamp),
 			msecs_to_jiffies(msecs));
-	mutex_lock(&device->mutex);
 
 	if (timeout > 0)
 		status = 0;
 	else if (timeout == 0) {
 		status = -ETIMEDOUT;
 		device->state = KGSL_STATE_HUNG;
+		KGSL_PWR_WARN(device, "state -> HUNG, device %d\n", device->id);
 	}
 	else
 		status = timeout;
 
-	KGSL_DRV_INFO("return %d\n", status);
 	return status;
 }
 
 static long kgsl_g12_ioctl_cmdwindow_write(struct kgsl_device_private *dev_priv,
-				     void __user *arg)
+					   void *data)
 {
-	int result = 0;
-	struct kgsl_cmdwindow_write param;
-
-	if (copy_from_user(&param, arg, sizeof(param))) {
-		result = -EFAULT;
-		goto done;
-	}
+	struct kgsl_cmdwindow_write *param = data;
 
-	result = kgsl_g12_cmdwindow_write(dev_priv->device,
-					     param.target,
-					     param.addr,
-					     param.data);
-
-	if (result != 0)
-		goto done;
-
-	if (copy_to_user(arg, &param, sizeof(param))) {
-		result = -EFAULT;
-		goto done;
-	}
-done:
-	return result;
+	return kgsl_g12_cmdwindow_write(dev_priv->device,
+					param->target,
+					param->addr,
+					param->data);
 }
 
 static long kgsl_g12_ioctl(struct kgsl_device_private *dev_priv,
-			unsigned int cmd,
-			unsigned long arg)
+			   unsigned int cmd, void *data)
 {
 	int result = 0;
 
 	switch (cmd) {
 	case IOCTL_KGSL_CMDWINDOW_WRITE:
-		result = kgsl_g12_ioctl_cmdwindow_write(dev_priv,
-							(void __user *)arg);
+		result = kgsl_g12_ioctl_cmdwindow_write(dev_priv, data);
 		break;
 	default:
-		KGSL_DRV_ERR("invalid ioctl code %08x\n", cmd);
+		KGSL_DRV_INFO(dev_priv->device,
+			"invalid ioctl code %08x\n", cmd);
 		result = -EINVAL;
 		break;
 	}
@@ -875,13 +788,22 @@
 
 }
 
-int kgsl_g12_getfunctable(struct kgsl_functable *ftbl)
+static void kgsl_g12_power_stats(struct kgsl_device *device,
+				struct kgsl_power_stats *stats)
+{
+	stats->total_time = 0;
+	stats->busy_time = 0;
+}
+
+static void kgsl_g12_getfunctable(struct kgsl_functable *ftbl)
 {
 
 	if (ftbl == NULL)
-		return KGSL_FAILURE;
+		return;
 	ftbl->device_regread = kgsl_g12_regread;
 	ftbl->device_regwrite = kgsl_g12_regwrite;
+	ftbl->device_regread_isr = kgsl_g12_regread_isr;
+	ftbl->device_regwrite_isr = kgsl_g12_regwrite_isr;
 	ftbl->device_setstate = kgsl_g12_setstate;
 	ftbl->device_idle = kgsl_g12_idle;
 	ftbl->device_isidle = kgsl_g12_isidle;
