--- drivers/gpu/msm/kgsl_mmu.c	2011-04-03 14:16:59.000000000 +0700
+++ drivers/gpu/msm/kgsl_mmu.c	2011-12-23 19:21:50.000000000 +0700
@@ -41,173 +37,569 @@
 };
 
 #define GSL_PT_PAGE_BITS_MASK	0x00000007
-#define GSL_PT_PAGE_ADDR_MASK	(~(KGSL_PAGESIZE - 1))
+#define GSL_PT_PAGE_ADDR_MASK	PAGE_MASK
 
 #define GSL_MMU_INT_MASK \
 	(MH_INTERRUPT_MASK__AXI_READ_ERROR | \
 	 MH_INTERRUPT_MASK__AXI_WRITE_ERROR)
 
-static const struct kgsl_mmu_reg mmu_reg[KGSL_DEVICE_MAX] = {
-	{
-		.config = REG_MH_MMU_CONFIG,
-		.mpu_base = REG_MH_MMU_MPU_BASE,
-		.mpu_end = REG_MH_MMU_MPU_END,
-		.va_range = REG_MH_MMU_VA_RANGE,
-		.pt_page = REG_MH_MMU_PT_BASE,
-		.page_fault = REG_MH_MMU_PAGE_FAULT,
-		.tran_error = REG_MH_MMU_TRAN_ERROR,
-		.invalidate = REG_MH_MMU_INVALIDATE,
-		.interrupt_mask = REG_MH_INTERRUPT_MASK,
-		.interrupt_status = REG_MH_INTERRUPT_STATUS,
-		.interrupt_clear = REG_MH_INTERRUPT_CLEAR
-	},
-	{
-		.config = ADDR_MH_MMU_CONFIG,
-		.mpu_base = ADDR_MH_MMU_MPU_BASE,
-		.mpu_end = ADDR_MH_MMU_MPU_END,
-		.va_range = ADDR_MH_MMU_VA_RANGE,
-		.pt_page = ADDR_MH_MMU_PT_BASE,
-		.page_fault = ADDR_MH_MMU_PAGE_FAULT,
-		.tran_error = ADDR_MH_MMU_TRAN_ERROR,
-		.invalidate = ADDR_MH_MMU_INVALIDATE,
-		.interrupt_mask = ADDR_MH_INTERRUPT_MASK,
-		.interrupt_status = ADDR_MH_INTERRUPT_STATUS,
-		.interrupt_clear = ADDR_MH_INTERRUPT_CLEAR
-	},
-	{
-		.config = ADDR_MH_MMU_CONFIG,
-		.mpu_base = ADDR_MH_MMU_MPU_BASE,
-		.mpu_end = ADDR_MH_MMU_MPU_END,
-		.va_range = ADDR_MH_MMU_VA_RANGE,
-		.pt_page = ADDR_MH_MMU_PT_BASE,
-		.page_fault = ADDR_MH_MMU_PAGE_FAULT,
-		.tran_error = ADDR_MH_MMU_TRAN_ERROR,
-		.invalidate = ADDR_MH_MMU_INVALIDATE,
-		.interrupt_mask = ADDR_MH_INTERRUPT_MASK,
-		.interrupt_status = ADDR_MH_INTERRUPT_STATUS,
-		.interrupt_clear = ADDR_MH_INTERRUPT_CLEAR
-	}
+static ssize_t
+sysfs_show_ptpool_entries(struct kobject *kobj,
+			  struct kobj_attribute *attr,
+			  char *buf)
+{
+	return sprintf(buf, "%d\n", kgsl_driver.ptpool.entries);
+}
+
+static ssize_t
+sysfs_show_ptpool_min(struct kobject *kobj,
+			 struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sprintf(buf, "%d\n", kgsl_driver.ptpool.static_entries);
+}
+
+static ssize_t
+sysfs_show_ptpool_chunks(struct kobject *kobj,
+			 struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sprintf(buf, "%d\n", kgsl_driver.ptpool.chunks);
+}
+
+static ssize_t
+sysfs_show_ptpool_ptsize(struct kobject *kobj,
+			 struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sprintf(buf, "%d\n", kgsl_driver.ptpool.ptsize);
+}
+
+static struct kobj_attribute attr_ptpool_entries = {
+	.attr = { .name = "ptpool_entries", .mode = 0444 },
+	.show = sysfs_show_ptpool_entries,
+	.store = NULL,
 };
 
-static inline uint32_t
-kgsl_pt_entry_get(struct kgsl_pagetable *pt, uint32_t va)
+static struct kobj_attribute attr_ptpool_min = {
+	.attr = { .name = "ptpool_min", .mode = 0444 },
+	.show = sysfs_show_ptpool_min,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_ptpool_chunks = {
+	.attr = { .name = "ptpool_chunks", .mode = 0444 },
+	.show = sysfs_show_ptpool_chunks,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_ptpool_ptsize = {
+	.attr = { .name = "ptpool_ptsize", .mode = 0444 },
+	.show = sysfs_show_ptpool_ptsize,
+	.store = NULL,
+};
+
+static struct attribute *ptpool_attrs[] = {
+	&attr_ptpool_entries.attr,
+	&attr_ptpool_min.attr,
+	&attr_ptpool_chunks.attr,
+	&attr_ptpool_ptsize.attr,
+	NULL,
+};
+
+static struct attribute_group ptpool_attr_group = {
+	.attrs = ptpool_attrs,
+};
+
+static int
+_kgsl_ptpool_add_entries(struct kgsl_ptpool *pool, int count, int dynamic)
 {
-	return (va - pt->va_base) >> KGSL_PAGESIZE_SHIFT;
+	struct kgsl_ptpool_chunk *chunk;
+	size_t size = ALIGN(count * pool->ptsize, PAGE_SIZE);
+
+	BUG_ON(count == 0);
+
+	if (get_order(size) >= MAX_ORDER) {
+		KGSL_CORE_ERR("ptpool allocation is too big: %d\n", size);
+		return -EINVAL;
+	}
+
+	chunk = kzalloc(sizeof(*chunk), GFP_KERNEL);
+	if (chunk == NULL) {
+		KGSL_CORE_ERR("kzalloc(%d) failed\n", sizeof(*chunk));
+		return -ENOMEM;
+	}
+
+	chunk->size = size;
+	chunk->count = count;
+	chunk->dynamic = dynamic;
+
+	chunk->data = dma_alloc_coherent(NULL, size,
+					 &chunk->phys, GFP_KERNEL);
+
+	if (chunk->data == NULL) {
+		KGSL_CORE_ERR("dma_alloc_coherent(%d) failed\n", size);
+		goto err;
+	}
+
+	chunk->bitmap = kzalloc(BITS_TO_LONGS(count) * 4, GFP_KERNEL);
+
+	if (chunk->bitmap == NULL) {
+		KGSL_CORE_ERR("kzalloc(%d) failed\n",
+			BITS_TO_LONGS(count) * 4);
+		goto err_dma;
+	}
+
+	list_add_tail(&chunk->list, &pool->list);
+
+	pool->chunks++;
+	pool->entries += count;
+
+	if (!dynamic)
+		pool->static_entries += count;
+
+	return 0;
+
+err_dma:
+	dma_free_coherent(NULL, chunk->size, chunk->data, chunk->phys);
+err:
+	kfree(chunk);
+	return -ENOMEM;
 }
 
-static inline void
-kgsl_pt_map_set(struct kgsl_pagetable *pt, uint32_t pte, uint32_t val)
+static void *
+_kgsl_ptpool_get_entry(struct kgsl_ptpool *pool, unsigned int *physaddr)
 {
-	uint32_t *baseptr = (uint32_t *)pt->base.hostptr;
-	writel(val, &baseptr[pte]);
+	struct kgsl_ptpool_chunk *chunk;
+
+	list_for_each_entry(chunk, &pool->list, list) {
+		int bit = find_first_zero_bit(chunk->bitmap, chunk->count);
+
+		if (bit >= chunk->count)
+			continue;
+
+		set_bit(bit, chunk->bitmap);
+		*physaddr = chunk->phys + (bit * pool->ptsize);
+
+		return chunk->data + (bit * pool->ptsize);
+	}
+
+	return NULL;
 }
 
-static inline uint32_t
-kgsl_pt_map_getaddr(struct kgsl_pagetable *pt, uint32_t pte)
+/**
+ * kgsl_ptpool_add
+ * @pool:  A pointer to a ptpool structure
+ * @entries: Number of entries to add
+ *
+ * Add static entries to the pagetable pool.
+ */
+
+int
+kgsl_ptpool_add(struct kgsl_ptpool *pool, int count)
 {
-	uint32_t *baseptr = (uint32_t *)pt->base.hostptr;
-	return readl(&baseptr[pte]) & GSL_PT_PAGE_ADDR_MASK;
+	int ret = 0;
+	BUG_ON(count == 0);
+
+	mutex_lock(&pool->lock);
+
+	/* Only 4MB can be allocated in one chunk, so larger allocations
+	   need to be split into multiple sections */
+
+	while (count) {
+		int entries = ((count * pool->ptsize) > SZ_4M) ?
+			SZ_4M / pool->ptsize : count;
+
+		/* Add the entries as static, i.e. they don't ever stand
+		   a chance of being removed */
+
+		ret =  _kgsl_ptpool_add_entries(pool, entries, 0);
+		if (ret)
+			break;
+
+		count -= entries;
+	}
+
+	mutex_unlock(&pool->lock);
+	return ret;
 }
 
-void kgsl_mh_intrcallback(struct kgsl_device *device)
+/**
+ * kgsl_ptpool_alloc
+ * @pool:  A pointer to a ptpool structure
+ * @addr: A pointer to store the physical address of the chunk
+ *
+ * Allocate a pagetable from the pool.  Returns the virtual address
+ * of the pagetable, the physical address is returned in physaddr
+ */
+
+void *kgsl_ptpool_alloc(struct kgsl_ptpool *pool, unsigned int *physaddr)
 {
-	unsigned int status = 0;
-	unsigned int reg;
+	void *addr = NULL;
+	int ret;
 
-	KGSL_MEM_VDBG("enter (device=%p)\n", device);
+	mutex_lock(&pool->lock);
+	addr = _kgsl_ptpool_get_entry(pool, physaddr);
+	if (addr)
+		goto done;
+
+	/* Add a chunk for 1 more pagetable and mark it as dynamic */
+	ret = _kgsl_ptpool_add_entries(pool, 1, 1);
+
+	if (ret)
+		goto done;
+
+	addr = _kgsl_ptpool_get_entry(pool, physaddr);
+done:
+	mutex_unlock(&pool->lock);
+	return addr;
+}
 
-	kgsl_regread(device, mmu_reg[device->id].interrupt_status, &status);
+static inline void _kgsl_ptpool_rm_chunk(struct kgsl_ptpool_chunk *chunk)
+{
+	list_del(&chunk->list);
 
-	if (status & MH_INTERRUPT_MASK__AXI_READ_ERROR) {
-		KGSL_MEM_FATAL("axi read error interrupt\n");
-	} else if (status & MH_INTERRUPT_MASK__AXI_WRITE_ERROR) {
-		KGSL_MEM_FATAL("axi write error interrupt\n");
-	} else if (status & MH_INTERRUPT_MASK__MMU_PAGE_FAULT) {
-		kgsl_regread(device, mmu_reg[device->id].page_fault, &reg);
-		KGSL_MEM_FATAL("mmu page fault interrupt: %08x\n", reg);
-	} else {
-		KGSL_MEM_DBG("bad bits in REG_MH_INTERRUPT_STATUS %08x\n",
-			     status);
+	if (chunk->data)
+		dma_free_coherent(NULL, chunk->size, chunk->data,
+			chunk->phys);
+	kfree(chunk->bitmap);
+	kfree(chunk);
+}
+
+/**
+ * kgsl_ptpool_free
+ * @pool:  A pointer to a ptpool structure
+ * @addr: A pointer to the virtual address to free
+ *
+ * Free a pagetable allocated from the pool
+ */
+
+void kgsl_ptpool_free(struct kgsl_ptpool *pool, void *addr)
+{
+	struct kgsl_ptpool_chunk *chunk, *tmp;
+
+	if (pool == NULL || addr == NULL)
+		return;
+
+	mutex_lock(&pool->lock);
+	list_for_each_entry_safe(chunk, tmp, &pool->list, list)  {
+		if (addr >=  chunk->data &&
+		    addr < chunk->data + chunk->size) {
+			int bit = ((unsigned long) (addr - chunk->data)) /
+				pool->ptsize;
+
+			clear_bit(bit, chunk->bitmap);
+			memset(addr, 0, pool->ptsize);
+
+			if (chunk->dynamic &&
+				bitmap_empty(chunk->bitmap, chunk->count))
+				_kgsl_ptpool_rm_chunk(chunk);
+
+			break;
+		}
 	}
 
-	kgsl_regwrite(device, mmu_reg[device->id].interrupt_clear, status);
+	mutex_unlock(&pool->lock);
+}
 
-	/*TODO: figure out how to handle errror interupts.
-	* specifically, page faults should probably nuke the client that
-	* caused them, but we don't have enough info to figure that out yet.
-	*/
+void kgsl_ptpool_destroy(struct kgsl_ptpool *pool)
+{
+	struct kgsl_ptpool_chunk *chunk, *tmp;
+
+	if (pool == NULL)
+		return;
 
-	KGSL_MEM_VDBG("return\n");
+	mutex_lock(&pool->lock);
+	list_for_each_entry_safe(chunk, tmp, &pool->list, list)
+		_kgsl_ptpool_rm_chunk(chunk);
+	mutex_unlock(&pool->lock);
+
+	memset(pool, 0, sizeof(*pool));
 }
 
-static int
-kgsl_ptpool_get(struct kgsl_memdesc *memdesc)
+/**
+ * kgsl_ptpool_init
+ * @pool:  A pointer to a ptpool structure to initialize
+ * @ptsize: The size of each pagetable entry
+ * @entries:  The number of inital entries to add to the pool
+ *
+ * Initalize a pool and allocate an initial chunk of entries.
+ */
+
+int kgsl_ptpool_init(struct kgsl_ptpool *pool, int ptsize, int entries)
 {
-	int pt;
-	unsigned long flags;
+	int ret = 0;
+	BUG_ON(ptsize == 0);
 
-	spin_lock_irqsave(&kgsl_driver.ptpool.lock, flags);
+	pool->ptsize = ptsize;
+	mutex_init(&pool->lock);
+	INIT_LIST_HEAD(&pool->list);
 
-	pt = find_next_zero_bit(kgsl_driver.ptpool.bitmap,
-				kgsl_driver.ptpool.entries, 0);
+	if (entries) {
+		ret = kgsl_ptpool_add(pool, entries);
+		if (ret)
+			return ret;
+	}
 
-	if (pt >= kgsl_driver.ptpool.entries) {
-		spin_unlock_irqrestore(&kgsl_driver.ptpool.lock, flags);
-		return -ENOMEM;
+	return sysfs_create_group(kgsl_driver.ptkobj, &ptpool_attr_group);
+}
+
+/* pt_mutex needs to be held in this function */
+
+static struct kgsl_pagetable *
+kgsl_get_pagetable(unsigned long name)
+{
+	struct kgsl_pagetable *pt;
+
+	list_for_each_entry(pt,	&kgsl_driver.pagetable_list, list) {
+		if (pt->name == name)
+			return pt;
 	}
 
-	set_bit(pt, kgsl_driver.ptpool.bitmap);
+	return NULL;
+}
 
-	spin_unlock_irqrestore(&kgsl_driver.ptpool.lock, flags);
+static struct kgsl_pagetable *
+_get_pt_from_kobj(struct kobject *kobj)
+{
+	unsigned long ptname;
 
-	/* The memory is zeroed at init time and when page tables are
-	   freed.0 This saves us from having to do the memset here */
+	if (!kobj)
+		return NULL;
 
-	memdesc->hostptr = kgsl_driver.ptpool.hostptr +
-		(pt * kgsl_driver.ptsize);
+	if (sscanf(kobj->name, "%ld", &ptname) != 1)
+		return NULL;
 
-	memdesc->physaddr = kgsl_driver.ptpool.physaddr +
-		(pt * kgsl_driver.ptsize);
+	return kgsl_get_pagetable(ptname);
+}
 
-	memdesc->size = kgsl_driver.ptsize;
+static ssize_t
+sysfs_show_entries(struct kobject *kobj,
+		   struct kobj_attribute *attr,
+		   char *buf)
+{
+	struct kgsl_pagetable *pt;
+	int ret = 0;
 
-	return 0;
+	mutex_lock(&kgsl_driver.pt_mutex);
+	pt = _get_pt_from_kobj(kobj);
+
+	if (pt)
+		ret += sprintf(buf, "%d\n", pt->stats.entries);
+
+	mutex_unlock(&kgsl_driver.pt_mutex);
+	return ret;
+}
+
+static ssize_t
+sysfs_show_mapped(struct kobject *kobj,
+		  struct kobj_attribute *attr,
+		  char *buf)
+{
+	struct kgsl_pagetable *pt;
+	int ret = 0;
+
+	mutex_lock(&kgsl_driver.pt_mutex);
+	pt = _get_pt_from_kobj(kobj);
+
+	if (pt)
+		ret += sprintf(buf, "%d\n", pt->stats.mapped);
+
+	mutex_unlock(&kgsl_driver.pt_mutex);
+	return ret;
+}
+
+static ssize_t
+sysfs_show_va_range(struct kobject *kobj,
+		    struct kobj_attribute *attr,
+		    char *buf)
+{
+	struct kgsl_pagetable *pt;
+	int ret = 0;
+
+	mutex_lock(&kgsl_driver.pt_mutex);
+	pt = _get_pt_from_kobj(kobj);
+
+	if (pt)
+		ret += sprintf(buf, "0x%x\n", pt->va_range);
+
+	mutex_unlock(&kgsl_driver.pt_mutex);
+	return ret;
+}
+
+static ssize_t
+sysfs_show_max_mapped(struct kobject *kobj,
+		      struct kobj_attribute *attr,
+		      char *buf)
+{
+	struct kgsl_pagetable *pt;
+	int ret = 0;
+
+	mutex_lock(&kgsl_driver.pt_mutex);
+	pt = _get_pt_from_kobj(kobj);
+
+	if (pt)
+		ret += sprintf(buf, "%d\n", pt->stats.max_mapped);
+
+	mutex_unlock(&kgsl_driver.pt_mutex);
+	return ret;
+}
+
+static ssize_t
+sysfs_show_max_entries(struct kobject *kobj,
+		       struct kobj_attribute *attr,
+		       char *buf)
+{
+	struct kgsl_pagetable *pt;
+	int ret = 0;
+
+	mutex_lock(&kgsl_driver.pt_mutex);
+	pt = _get_pt_from_kobj(kobj);
+
+	if (pt)
+		ret += sprintf(buf, "%d\n", pt->stats.max_entries);
+
+	mutex_unlock(&kgsl_driver.pt_mutex);
+	return ret;
 }
 
+static struct kobj_attribute attr_entries = {
+	.attr = { .name = "entries", .mode = 0444 },
+	.show = sysfs_show_entries,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_mapped = {
+	.attr = { .name = "mapped", .mode = 0444 },
+	.show = sysfs_show_mapped,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_va_range = {
+	.attr = { .name = "va_range", .mode = 0444 },
+	.show = sysfs_show_va_range,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_max_mapped = {
+	.attr = { .name = "max_mapped", .mode = 0444 },
+	.show = sysfs_show_max_mapped,
+	.store = NULL,
+};
+
+static struct kobj_attribute attr_max_entries = {
+	.attr = { .name = "max_entries", .mode = 0444 },
+	.show = sysfs_show_max_entries,
+	.store = NULL,
+};
+
+static struct attribute *pagetable_attrs[] = {
+	&attr_entries.attr,
+	&attr_mapped.attr,
+	&attr_va_range.attr,
+	&attr_max_mapped.attr,
+	&attr_max_entries.attr,
+	NULL,
+};
+
+static struct attribute_group pagetable_attr_group = {
+	.attrs = pagetable_attrs,
+};
+
 static void
-kgsl_ptpool_put(struct kgsl_memdesc *memdesc)
+pagetable_remove_sysfs_objects(struct kgsl_pagetable *pagetable)
 {
-	int pt;
-	unsigned long flags;
+	if (pagetable->kobj)
+		sysfs_remove_group(pagetable->kobj,
+				   &pagetable_attr_group);
 
-	if (memdesc->hostptr == NULL)
-		return;
+	kobject_put(pagetable->kobj);
+}
 
-	pt = (memdesc->hostptr - kgsl_driver.ptpool.hostptr)
-		/ kgsl_driver.ptsize;
+static int
+pagetable_add_sysfs_objects(struct kgsl_pagetable *pagetable)
+{
+	char ptname[16];
+	int ret = -ENOMEM;
 
-	/* Clear the memory now to avoid having to do it next time
-	   these entries are allocated */
+	snprintf(ptname, sizeof(ptname), "%d", pagetable->name);
+	pagetable->kobj = kobject_create_and_add(ptname,
+						 kgsl_driver.ptkobj);
+	if (pagetable->kobj == NULL)
+		goto err;
+
+	ret = sysfs_create_group(pagetable->kobj, &pagetable_attr_group);
+
+err:
+	if (ret) {
+		if (pagetable->kobj)
+			kobject_put(pagetable->kobj);
+
+		pagetable->kobj = NULL;
+	}
+
+	return ret;
+}
+
+static inline uint32_t
+kgsl_pt_entry_get(struct kgsl_pagetable *pt, uint32_t va)
+{
+	return (va - pt->va_base) >> PAGE_SHIFT;
+}
 
-	memset(memdesc->hostptr, 0, memdesc->size);
+static inline void
+kgsl_pt_map_set(struct kgsl_pagetable *pt, uint32_t pte, uint32_t val)
+{
+	uint32_t *baseptr = (uint32_t *)pt->base.hostptr;
+	writel(val, &baseptr[pte]);
+}
 
-	spin_lock_irqsave(&kgsl_driver.ptpool.lock, flags);
-	clear_bit(pt, kgsl_driver.ptpool.bitmap);
-	spin_unlock_irqrestore(&kgsl_driver.ptpool.lock, flags);
+static inline uint32_t
+kgsl_pt_map_getaddr(struct kgsl_pagetable *pt, uint32_t pte)
+{
+	uint32_t *baseptr = (uint32_t *)pt->base.hostptr;
+	return readl(&baseptr[pte]) & GSL_PT_PAGE_ADDR_MASK;
+}
+
+void kgsl_mh_intrcallback(struct kgsl_device *device)
+{
+	unsigned int status = 0;
+	unsigned int reg;
+
+	kgsl_regread_isr(device, device->mmu.reg.interrupt_status, &status);
+
+	if (status & MH_INTERRUPT_MASK__AXI_READ_ERROR) {
+		kgsl_regread_isr(device, device->mmu.reg.axi_error, &reg);
+		KGSL_MEM_CRIT(device, "axi read error interrupt: %08x\n", reg);
+	} else if (status & MH_INTERRUPT_MASK__AXI_WRITE_ERROR) {
+		kgsl_regread_isr(device, device->mmu.reg.axi_error, &reg);
+		KGSL_MEM_CRIT(device, "axi write error interrupt: %08x\n", reg);
+	} else if (status & MH_INTERRUPT_MASK__MMU_PAGE_FAULT) {
+		kgsl_regread_isr(device, device->mmu.reg.page_fault, &reg);
+		KGSL_MEM_CRIT(device, "mmu page fault interrupt: %08x\n", reg);
+	} else {
+		KGSL_MEM_WARN(device,
+			"bad bits in REG_MH_INTERRUPT_STATUS %08x\n", status);
+	}
+
+	kgsl_regwrite_isr(device, device->mmu.reg.interrupt_clear, status);
+
+	/*TODO: figure out how to handle errror interupts.
+	* specifically, page faults should probably nuke the client that
+	* caused them, but we don't have enough info to figure that out yet.
+	*/
 }
 
 static struct kgsl_pagetable *kgsl_mmu_createpagetableobject(
-				struct kgsl_mmu *mmu,
 				unsigned int name)
 {
 	int status = 0;
 	struct kgsl_pagetable *pagetable = NULL;
 
-	KGSL_MEM_VDBG("enter (mmu=%p)\n", mmu);
-
 	pagetable = kzalloc(sizeof(struct kgsl_pagetable), GFP_KERNEL);
 	if (pagetable == NULL) {
-		KGSL_MEM_ERR("Unable to allocate pagetable object.\n");
+		KGSL_CORE_ERR("kzalloc(%d) failed\n",
+			sizeof(struct kgsl_pagetable));
 		return NULL;
 	}
 
@@ -683,15 +1039,15 @@
 				GSL_PT_SUPER_PTE);
 	}
 
+	/* Remove the statistics */
+	pagetable->stats.entries--;
+	pagetable->stats.mapped -= range;
+
 	mb();
-	dsb();
-	outer_sync();
 	spin_unlock(&pagetable->lock);
 
 	gen_pool_free(pagetable->pool, gpuaddr, range);
 
-	KGSL_MEM_VDBG("return %d\n", 0);
-
 	return 0;
 }
 #endif /*CONFIG_MSM_KGSL_MMU*/
